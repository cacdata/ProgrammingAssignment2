install.packages(c("KernSmooth"))
library (KernSmooth)
swirl()
library (swirl)
swirl()
x
x[1:10]
x[is.na(x)]
y <- x[!is.na(x)]
y
y[y>0]
x[x>0]
x[!is.na(x) & x > 0]
c(x[3],x{5],x[7])
c(x[3],x[5],x[7])
x[c(3,5,7)]
x[0]
x[3000]
x[c(-2,-10])]
x[c(-2,-10)]
x[-c(2,10)]
vect <-c(foo =11, bar =2, norf =NA)
vect
names(vect)
vect2 <- c(11,2,NA)
names(vect2) <- c("foo","bar","norf")
identical(vect, vect2)
vect["bar"]
vect[bar]
vect[c("foo","bar")]
my_vector <- 1:20
my_vector
dim(my_vector)
length(my_vector)
dim(my_vector) <- c(4,5)
dim(my_vector)
attributes
attributes(my_vector)
my_vector
class(my_vector)
my_matrix <- my_vector
?matrix
my_matrix2 <- matrix(1:20,4,5)
my_matrix2
identical(my_matrix,my_matrix2)
patients = c("Bill","Gina", "Kelly","Sean")
patients <- c("Bill","Gina", "Kelly","Sean")
cbind(patients,my_matrix)
my_data <- data.frame(patients, my_matrix)
my_data
class(my_data)
cnames <- c("patient", "age", "weight", "bp", "rating", "test")
colnames(my_data) <- cnames
my_data
TRUE == TRUE
(FALSE == TRUE) == FALSE
6 == 7
6 < 7
10 <= 10
5 != 7
! (5==7)
! 5==7
FALSE & FALSE
TRUE & c(TRUE, FALSE, FALSE)
TRUE && c(TRUE,FALSE,FALSE)
TRUE | c(TRUE,FALSE,FALSE)
TRUE || c(TRUE,FALSE,FALSE)
5 > 8 || 6 != 8 && 4 > 3.9
isTRUE(6>4)
identical ('twins','twins')
xor(5==6,!FALSE)
ints <-sample(10)
ints
ints > 5
which(ints>7)
any(ints < 0)
all (ints > 0)
head(flags)
dim(flags)
viewinfo)(flags)
viewinfo(flags)
viewinfo
class(flags)
cls_lst <- lapply(flags,class)
cls_list <- lapply(flags,class)
cls_list
class(cls_list)
as.character(cls_list)
cls_vect <- sapply(flags,class)
class(cls_vect)
sum(flags$orange)
flag_colors <- flags[,11:17]
head(flag_colors
)
lapply(flag_colors,sum)
sapply(flag_colors,sum)
sapply(flag_colors,mean)
flag_shapes <- flags[,19:23]
sapply(flag_shapes,range())
sapply(flag_shapes,range
)
lapply(flag_shapes,range)
shape_mat <- sapply(flag_shapes,range)
shape_mat
class(shape_mat)
unique(c(3, 4, 5, 5, 5, 6, 6))
unique_vals -> lapply(flags,unique)
unique_vals <- lapply(flags,unique)
unique_vals
sapply(unique_vals,length)
sapply(flags,unique)
lapply(unique_vals, function(elem) elem[2])
getwd
getwd()
cd gethub
ls
setwd("Users/cindycohen/GitHub/ProgrammingAssignment2")
path
getwd()
help setwd
? setwd
setwd("~/GitHub")
setwd("~/GitHub/ProgrammingAssignment2/")
library
help library
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
bigVec <- makeVector(1:1000) # now we have an object 'bigVec' of type list
> biggerVec <- makeVector(1:100000) # 'biggerVec' of type list with 100,000 numbers
bigVec <- makeVector(1:1000) # now we have an object 'bigVec' of type list
biggerVec <- makeVector(1:100000) # 'biggerVec' of type list with 100,000 numbers
cachemean(bigVec)
cachemean(bigVec)
cachemean(biggerVec
)
cachemean(biggerVec)
bigVec <- makeVector(1:2)
cachemean(bigVec)
cachemean(bigVec)
tVec <- makeVector(1:2)
cachemean(tVec)
help sole
help solve
solve?
w
solve()
help solve()
? solve()
g <- matrix(c(-1, -2, 1, 1), 2, 2)
g
solve(g)
makeCacheMatrix <- function(x = matrix()) {
## reset inverse to null if making new matrx
inv <- NULL
## create a set function so I can update the matrix object later if I need to
set <- function(y) {
x <<- y
inv <<- NULL
}
## get returns the original matrix
get <- function() x
## setinverse/getinverse solve the inverse matrix and returns the inverse
## note if setinverse has not been called on the object than get inverse will return NULL
setinverse <- function(solve) inv <<- solve
getinverse <- function() inv
## and the list of methods available to the calling function
## and how it maps to the internal names
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## This function will return the inverse of the passed matrix object
## that was created by makeCacheMatrix
## by either calculating the inverse or returning the previously
## cached inverse if it has calculated it before for that object
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
## check to see if it already known
inv <- x$getinverse()
if(!is.null(inv)) {
## not null means we have a cached value
## so go ahead and return that
message("getting cached data")
return(inv)
}
## if we got here, then have not previously cached
data <- x$get()
## so use soure to get the inverse
inv <- source(data, ...)
## cache it
x$setmean(inv)
## return the newly calc'ed inverse
inv
}
source("cachematrix.R")
amatrix = makeCacheMatrix(matrix(c(1,2,3,4), nrow=2, ncol=2))
amatrix$get()
cacheSolve(amatrix)
cacheSolve(amatrix)
local
source('~/GitHub/ProgrammingAssignment2/cachematrix.R')
qui
source("cachematrix.R")
amatrix = makeCacheMatrix(matrix(c(1,2,3,4), nrow=2, ncol=2))
amatrix$get()
cacheSolve(amatrix)
source('~/GitHub/ProgrammingAssignment2/cachematrix.R')
cacheSolve(amatrix)
source('~/GitHub/ProgrammingAssignment2/cachematrix.R')
cacheSolve(amatrix)
source('~/GitHub/ProgrammingAssignment2/cachematrix.R')
cacheSolve(amatrix)
source('~/GitHub/ProgrammingAssignment2/cachematrix.R')
cacheSolve(amatrix)
source('~/GitHub/ProgrammingAssignment2/cachematrix.R')
cacheSolve(amatrix)
amatrix$getinverse()
cacheSolve(amatrix)
amatrix$set(matrix(c(0,5,99,66), nrow=2, ncol=2))
cacheSolve(amatrix)
amatrix$get()
amatrix$getinverse()
cacheSolve(amatrix)
source('~/GitHub/ProgrammingAssignment2/cachematrix.R')
source('~/GitHub/ProgrammingAssignment2/cachematrix.R')
